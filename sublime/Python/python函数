函数： 一般是执行某种功能，是一个对象  def function([a,b,...]): 代码块  ocp原则
    1.函数的参数：形参和实参
        传递参数：形参传递：def fn(a=2,b=1,c=10), fn(1,2)默认会给c=10
                     实参传递：位置参数和关键字参数。两者可以混合使用，混合使用前,位置参数先行
        实参：函数调用时，解析器不会解析它的类型，它可以是任意类型的对象。
            注意：实参在函数中赋值操作，和值是否发生改变。改变量还是对象。
        ！不定长参数:fn(a,b,*c),*c中数据都保存在一个元组中,带*号数据只能有一个,这种传参只接受位置参数.带*号后的所有参数都必须以关键字参数进行传递。
                 eg:def fn(a,*b,c):    fn(1,2,3,c=5)
        如果接受关键字参数则采用**a,即  fn(a,b,**c),数据保存在一个字典中
        解包：eg:def fn(a,b,c)   t=(1,2,3)  fn(*t)
            *t：对序列进行解包
            **t:对字典进行解包
        函数作用域：函数调用时创建,调用结束时销毁。调用即创建
        变量的查找：有限当前作用域，若无则向上作用域找，否则抛出异常
    2.文档字符串help()函数:内置函数,用来查询函数的用法
            def fn(a:int,b:float,c:str) ->:非强制类型
    3.命名空间：是一个字典，locals()获取当前作用域0和globals()获取全局作用域,外部无法查看函数内部的,函数内部可以查看外部的  
    4.递归：思想是将大问题分解成一个个的小问题，直到无法分解。即函数里面套函数
          无穷递归：如果这个函数被调用，程序内存会溢出，效果类似与死循环。
          递归函数的两个条件：1.基线条件
                                问题分解成最小问题，满足基线条件就不在执行
                            2.递归条件：
                                将问题继续分解的``条件  
    5.高阶函数：将函数作为参数放入函数，函数的高度定制
    6.filter(fn,element)函数:filter调用完后，fn就没用了(！！！！是fn不是fn())
        匿名函数：lambda函数表达式(语法糖)，只能用于专门创建一些简单的函数
            语法: lambda 参数列表：返回值    eg：lambda：i:i>5
    7.map()函数：将可迭代对象中的所有元素进行指定操作，然后添加到一个新的元素返回
            eg:map(fn(),iteral):fn是所进行的操作，iteral是操作的迭代对象    
    8.reduce():必须接受两个参数，reduce(fn,iter)  返回累积结果  functools
    9.sort()和sorted():前者会改变对象，后者不改变，都是返回序列
            eg：sort(key=len)&&sort(key=int)按照长度和int类型
    10.闭包：确保数据的安全
            要件: 1.函数嵌套 
                  2.内部函数作为返回值
                  3.内部函数必须使用到外部的函数的变量   
    11.装饰器：便于修改和维护，不改变原函数以及不违背OCP。进行对函数的拓展
    12.偏函数：把一个参数固定住，形成一个新的函数，通过设定参数的默认值来降低函数的难度，主要是functools.partial()