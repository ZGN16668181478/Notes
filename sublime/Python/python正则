正则表达式：仅仅用来匹配字符串，也相当于一种语言
    元字符： 
        .：通配符，代指出\n意外任意一个单个字符，在没有字符的.号就是一个简单的符号，没有其他意义
        ^：^string必须是string开头的
        $：string$必须是string结尾的
        []: 只匹配里面的一个字符
        (): 括号作为整体, 里面东西作为整体匹配
        在[]里的字符基本上没有特别的含义
        重复匹配：
            *：[0,正无穷]，在没有字符的*号就是一个简单的符号，没有其他意义  贪婪
            ?：[0,1]
            +：[1,正无穷]   贪婪
            {}：eg:{1,2}  {1,}(不写默认是正无穷)
            | ：或
            *? :  解决*贪婪
            +? : 解决+贪婪
        \:反斜杠后跟元字符取出特殊功能，跟普通字符实现特殊功能
            \d:[0-9]
            \D:[^0-9]
            \s:匹配任何空白字符
            \S:非空白字符
            \w:匹配任何数字字母字符，[a-zA-Z0-9]
            \W:[^a-zA-Z0-9]
            \b:匹配一个特殊边界的字符：像a#
            \\\\:在re模块\有特殊意义，\在python解释器里也有特殊意义，都需要进行转译
        eg:re.search('(?P<id>\d{3})/(?P<name>\w{3})','str_name')
    方法：  
        当中有个flag参数 ： 标志位，用于控制正则表达式的匹配方式
            re.I : 忽略大小写
            re.L : 做本地户识别
            re.M : 多行匹配, 影响开头结尾符 ^ $
            re.s : 是.匹配所有包括换行符在内的所有字符
            re.U : 根据Unicode字符集解析字符，影响 \W \w \b \B
            re.X : 使我们更灵活的格式理解正则表达式
        findall():所有结果返回到一个列表里
        finditer():查找所有，将内容返回到一个迭代器里，然后通过next获取,防止内存不够
        search():返回匹配到的第一个对象(object),找到之后就不会再找了,调用group()返回结果
        match():只匹配把规则当成匹配字符串第一段的，通过group()返回结果
        split():
        sub(pattern,repl,string,count):进行替换  返回值是个字符串
        subn(pattern,repl,string,count):可以显示替换次数，返回值是个元组
        compile():比如findall('pattern','str_name')中，需要对pattern进行编译，然而compile方法直接将patter编译成一个对象，然后通过该对象进行调用findall等方法
            eg:re.compile(pattern).findall(str_name) 