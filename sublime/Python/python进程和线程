为了实现多任务，提高效率
并发：看上去一起执行，任务数多于CPU核心数
并行：真正一起执行，任务数小于或等于CPU核心数
多任务的方式：多进程模式，多线程模式，协程模式，多线程+多进程模式
join:等待进程或线程执行完

进程：是系统中程序执行和资源分配的基本单位，每个进程都有自己的数据段、代码段和堆栈段(对于操作系统，一个任务就是一个进程)
    join:让子进程插入父进程，让子进程执行完再父进程结束(只能子进程开始才能进行插入)
    进程池：Pool(num),里面的子进程执行顺序是操作系统决定的
    进程的封装：继承了Process，执行了start方法，就会启动进程并调用其中方法
    进程间通信：可以通过队列Queue,分别传入到几个进程内,进程内存入，其他进程可以读取到

线程：通常叫做轻型的进程，没有独立的存储空间，共享内存空间的并发执行的多任务，每个线程都共享一个进程的资源，是最小的执行单元
    主要有：_thread模块：  低级模块(靠近底层的模块)
           threading：    高级模块(对_thread模块进行了封装)
    线程的数据共享: 造成数据容易乱、
        解决数据乱：
            锁：threading.Lock()，阻止了线程并发执行，执行以单线程，大大降低速度，当存在多个锁时，可能会引起死锁，导致多个线程挂起，只能靠操作系统强制终止
                1.try:  finally:
                2.with lock
            local = threading.local:每个线程有个独立的存储空间，同样的变量存储的数据不一样，类似于局部变量，eg:local.x = 10
    信号量控制线程数：threading.Semaphore(int)
    凑够线程数再执行：threading.Barrier(int)
    定时执行线程: threading.Time(int,func)   几秒后执行 
    事件：threading.Event, 触发事件才会执行线程
    消费者和生产者：生产不息，消费不止，队列放了取，取了放
    线程调度：安排线程执行顺序

计算密集型：大量计算，线程太多花在切换线程事件就太多，降低效率
IO密集型：CPU消耗少，都在等待资源执行，对它而言，任务越多效率越高

