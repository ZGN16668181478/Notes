类：类提供默认行为，是实例的工厂，类也是一个对象，用来创建对象的对象。是type类型的对象 
    希望：将可能会出现的大批错误改成尽可能少的错误。eg:创建对象时，必须设置name属性，若不设置队形就无法创建，并且是自动创建
    创建对象： 1.创建一个对象
              2.在内存中创建一个新对象
              3.类型代码块的代码就执行了  eg:print('xxx')
              4.__init__(self)方法执行 
              3.将对象的id赋值给变量
    属性：类里定义的变量，一般不会共享
    调用方法：解析器默认会传递一个参数，所以在定义函数(方法)时至少定义一个形参
            eg:def fn(self):这里的self指的是对象调用函数，就是这个对象本身
    类中的属性和方法：
        类属性：直接在类中定义，只能通过类对象修改，无法通过实例对象修改。
        实例属性：通过实例对象添加的属性，只能通过实例对象进行访问和修改，无法通过类对象
        动态添加属性：MethodType(fn,value)  类似一个偏函数
        限制添加其他属性：__slot__ = (e1,e2,e3) __slot__之外的不能添加了
        类方法：有@classmethod修饰的方法，有参数cls，类cls方便调用类中属性和方法
                eg：@classmethod   def test(cl):
        实例方法：eg:def test(self):
            当通过实例对象调用时，self自动传入
            当通过类调用时，不会自动传入，需要手动传入self
        静态方法：有@staticmethod修饰的方法，没有参数,一般都是工具方法，都可以调用
                eg: @staticmethod  def test():
    特殊(magic)方法__init__(self):对象创建后执行，调用类创建时，类后面所有的参数都会一次传递给init()中，self是调用就会传入，不需要自己另外传入参数
    垃圾回收:对象没有被引用后自动删除，程序结束后自动删除所有，通过特殊方法__del__(self)
封装：让访问受限制
        1.隐藏属性名,使调用者无法随意修改属性
        2.增加getter和setter方法  即get_attribute()返回获取的属性,而setter_attribute(name)无返回值
    隐藏属性：__attribute  无法通过对象访问，但可以_className__attribute 这是python自动分配
                _attibute  一般都表示隐藏属性
    property和attribute.setter装饰器： 
        property:将一个get方法，转换成对象的属性，即get_name
    运算符重载：即重写运算方法，eg: __add__,__str__进行重写
继承：让子类(衍生类)获取到父类(超类，基类，super)的属性或方法,避免重复性编写代码,符合OCP原则。
    eg:Person([父类]) 当父类为空或不写时，是直接继承object   所有的对象都是object子类
        isinstance(a,b):检查a是否是b的实例。
        issubclass(a,b):检查a是否是b的子类
    对于类继承多继承的类：父类中方法名相同时，默认调用的是父类括号靠前的类
        eg: child(father) father(First,Second)  先调用First方法
    重写
    super():用来获取当前类的父类，返回对象时不需要传递self
    多重继承：eg:MyClass(A,B)   如果多个父类有同名方法，则会按照继承顺序查找，找过则不会找了
            eg:先找A,A没有就找A的父类，以此类推。
多态：不需要太多的注意类型，只要符合某种要求，就可以调用数据。 
    鸭子类型：如果一个东西，走路像鸭子，叫声像鸭子，那么他就是鸭子

小结：
    封装：确保对象中的数据安全
    继承：确保了对象的可扩展性
    多态：确保了程序的灵活性，减少数据对类型的绑定